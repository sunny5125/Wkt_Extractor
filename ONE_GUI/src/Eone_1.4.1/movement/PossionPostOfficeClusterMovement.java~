

/** 
 * Random waypoint movement where the coordinates are restricted to circular
 * area defined by a central point and range  where random coordinates are generated by possion movement 
 * @Anand Chowdhury
 */
package movement;

import core.Coord;
import core.Settings;
import java.util.Random;
import core.SimClock;
public class PossionPostOfficeClusterMovement extends RandomWaypoint {
    /** Range of the cluster */
    public static final String CLUSTER_RANGE = "clusterRange";
    /** Center point of the cluster */
    public static final String CLUSTER_CENTER = "clusterCenter";
    
    public static final String CLUSTER_DB_LOC = "dblocation";
    //Speed of movementime
    public static final String SPEED = "speed";
    // Rate parameter for Possion Movementmodel
    public static final String CLUSTER_RATE = "clusterRate";
    //waiting time for dtn nodes
    public static final String WAIT_TIME = "waitTime";
    //** lamda of the possion movement */
    public static final String LAMDA="lamda";
    //** Threshold of the movment */
    public static final String THRESHOLD="threshold";
    
    private int flag = 0;
    private int     p_x_center, p_y_center;
    private int db_x, db_y;
    private double last_x,last_y;
    private double  p_range ;
    private int clusterRate=0;
    private double nextInterval=0;
    private double vMin,vMax;//minimum and maximum velocity
    private double wMin,wMax;//minimum and maximum waiting time
    private double total;
    private double total1;
//-------------------------------------------------------    
    private double lamda=12;//1200
    private int threshold=4;//7 
    private int f=0;
    private double x;
    private double y;
    
    ;
        
    public PossionPostOfficeClusterMovement(Settings s) {
        super(s);
        System.out.println("in possion");
        if (s.contains(CLUSTER_RANGE)){
            this.p_range = s.getDouble(CLUSTER_RANGE);
            
        }
        if (s.contains(CLUSTER_CENTER)){
            int[] center = s.getCsvInts(CLUSTER_CENTER,2);
            this.p_x_center = center[0];
            this.p_y_center = center[1];
            
        }
        if (s.contains(CLUSTER_DB_LOC)){
            int[] dbloc = s.getCsvInts(CLUSTER_DB_LOC,2);
            this.db_x = dbloc[0];
            this.db_y = dbloc[1];
        }
        if(s.contains(SPEED))
        {
            double[] speed =s.getCsvDoubles(SPEED,2);
            this.vMin=speed[0];
            this.vMax=speed[1];
        }
        if (s.contains(CLUSTER_RATE)){
            this.clusterRate = s.getInt(CLUSTER_RATE);
            //System.out.println("Cluster Rate:"+this.clusterRate);+
        }
        if (s.contains(LAMDA)) {
             this.lamda=s.getInt(LAMDA);
           //  System.out.println("l= "+this.lamda);
        }
         if (s.contains(THRESHOLD)) {
             this.threshold=s.getInt(THRESHOLD);
        }
       
        
        
        last_x=db_x;
        last_y=db_y;
        nextInterval=possionNextInterval();
    }
    
    private PossionPostOfficeClusterMovement(PossionPostOfficeClusterMovement cmv) {
        super(cmv);
        this.p_range = cmv.p_range;
        this.p_x_center = cmv.p_x_center;
        this.p_y_center = cmv.p_y_center;
        this.db_x = cmv.db_x;
        this.db_y = cmv.db_y;
        this.flag = cmv.flag;
        this.clusterRate=cmv.clusterRate;
        this.vMin=cmv.vMin;
        this.vMax=cmv.vMax;
        this.last_x=cmv.last_x;
        this.last_y=cmv.last_y;
        this.nextInterval=cmv.nextInterval;
        this.threshold=cmv.threshold;
        this.lamda=cmv.lamda;  
         this.x=0;
         this.y=0;
         this.total=0;
         this.total1=0;

    }
    
    @Override
    protected Coord randomCoord() {
          
        
	  double tPause=this.generateWaitTime()/60;
	  double velocity=this.generateSpeed();
      

	 this.x = (rng.nextDouble()*2 - 1)*this.p_range;
	 this.y = (rng.nextDouble()*2 - 1)*this.p_range;
	while (x*x + y*y>this.p_range*this.p_range) 
	{
	    this.x = (rng.nextDouble()*2 - 1)*this.p_range;
	    this.y = (rng.nextDouble()*2 - 1)*this.p_range;
	}
	
    //   System.out.println("center->("+p_x_center+","+p_y_center+")"+" (x,y)->("+(x+p_x_center)+","+(y+p_y_center)+") distance->"+distance(x+p_x_center,y+p_y_center,this.p_x_center,this.p_y_center)/60);
        
      
         
        if(this.flag==1)
        {
             
            this.nextInterval=possionNextInterval();
            this.flag = 0;
            this.total1=0;
            this.x=this.db_x;
            this.y=this.db_y;
	        this.last_x=this.db_x;
	        this.last_y=this.db_y;
	        this.f=0; 
       // System.out.println("hello");	 
        }
        else
        {
            //System.out.println(this.p_x_center+","+this.p_y_center+" "+this.db_x+","+this.db_y+" "+this.p_range);               
            this.x += this.p_x_center;
            this.y += this.p_y_center;
           
            this.flag=timeLeft(this.db_x,this.db_y,this.x,this.y,velocity,tPause);  
	    
        }
   
         // System.out.println("flag = "+this.flag); 
       try
       {
              
           if((this.flag==0) || (this.flag==1)){
           
               if(this.x==this.db_x && this.y==this.db_y)
                  {// System.out.println(SimClock.getTime());                 
                    }
               else if(this.last_x==this.db_x && this.last_y==this.db_y) 
                    {//System.out.println(SimClock.getTime());
                      }                                     
              this.last_x=this.x;//moving p1<-p
              this.last_y=this.y;
              return new Coord(this.x,this.y);
               
           }
           else{
           
           return new Coord(this.last_x,this.last_y);
            //return new Coord(this.x,this.y);
           }
           
        }
       catch(Exception e)
       {
              //   System.out.println("error"+e);
         }    
            
         return new Coord(this.last_x,this.last_y);
        
        
    }
    
    @Override
    public int getMaxX() {
        return (int)Math.ceil(this.p_x_center + this.p_range);
    }

    @Override
    public int getMaxY() {
        return (int)Math.ceil(this.p_y_center + this.p_range);
    }
    private double possionNextInterval()
    {
    
        double nextTime=0;
          //nextTimeMath.log(r.nextInt(RAND_MAX)/(RAND_MAX+1.0))*lamda;
          nextTime = -Math.log(rng.nextDouble())*lamda; //uniform possion time interval       
         // System.out.println("lamda"+lamda);            
         nextTime/=60;
          nextTime += (minWaitTime/60)+threshold;
          //System.out.println("nxt "+nextTime); 
          return nextTime;
    }





	private boolean check(double x,double y,double v,double tPause)
	{
	  	
		this.total1+=check_time(this.last_x,this.last_y,this.x,this.y,v)/60+tPause;
		this.total= this.total1+check_time(this.db_x,this.db_y,this.x,this.y,this.vMax)/60;
		
		
	  //  System.out.println("check = "+(check_time(this.last_x,this.last_y,this.x,this.y,v)/60)+" tpause  "+tPause+" check2 = "+(check_time(this.db_x,this.db_y,this.x,this.y,this.vMax)/60));
	 //   System.out.println("total"+this.total+ " "+this.nextInterval);     
	          	
		
		if(this.total>this.nextInterval)
		{
			//System.out.println("false");
			return false;
		}
		else
		{
			//System.out.println("true");
			return true;
		}
	}



    private double check_time(double last_x,double last_y,double x,double y,double v)
    {
    	double ax,ay;
        double distance;
        double time;
        ax=x-last_x;
        ay=y-last_y;
        ax=ax*ax;
        ay=ay*ay;
        distance=Math.sqrt((double)(ax+ay));
        time=distance/v;//T(p,p1)
        return time;
    }
    private int timeLeft(double db_x,double db_y, double x, double y,double v,double tP)
    {
       
        if(check(x,y,v,tP))
        {
           //  System.out.println(" T "+(this.threshold+this.total)+"lamda"+this.lamda);
             if((this.threshold+this.total)>this.nextInterval) 
                {
                    
                     this.f=1;
                     return 1;                                                         
                    
                }
        
              return 0;
          }             
        else
        {
         
            this.total=0;
            this.total1=0;
        
           return 2;
           
        }
     }
     
    double distance(double x,double y,double x1,double y1)
    {
        return Math.sqrt(((x-x1)*(x-x1))+((y-y1)*(y-y1)));
    }
    
    @Override
    public PossionPostOfficeClusterMovement replicate() {
        return new PossionPostOfficeClusterMovement(this);
    }

     @Override
     /**
	 * Generates and returns a speed value between min and max of the 
	 * {@link #WAIT_TIME} setting.
	 * @return A new speed between min and max values 
	 */
	protected double generateSpeed() {
		if (rng == null) {
			return 1;
		}
	          else if(this.f==1){     
                     double vel=distance(this.x,this.y,this.db_x,this.db_y)/((this.nextInterval-this.total1)*60);//in m/s
                     if(vel>maxSpeed)
                     return maxSpeed;
                     else if(vel>minSpeed)
                       return vel;
                      else
                        return minSpeed; 
                      
                   
                   
                   }
                   else
                   {
 
                      return ((maxSpeed - minSpeed) * rng.nextDouble() + minSpeed);
 
                   }                     	             
	             } 
        
}
